<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>记 LSPosed 的一个随机崩溃的调查过程 | 5ec1cff's blog</title><meta name="author" content="5ec1cff"><meta name="copyright" content="5ec1cff"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="记 LSPosed 的一个随机崩溃的调查过程LSPosed 已经停更数个月，由于缺少维护，问题不断显现。从上个月开始，就看到有不少用户汇报 LSPosed 存在导致系统概率性 crash 或 bootloop 的问题，然而原因却让人摸不着头脑。在最近，经过几天的与问题用户的跟踪调查，总算有了眉目。 初见收到的 crash dump 往往具有下面的特征： 1234567891011121314151">
<meta property="og:type" content="article">
<meta property="og:title" content="记 LSPosed 的一个随机崩溃的调查过程">
<meta property="og:url" content="https://5ec1cff.github.io/my-blog/2024/06/27/lsp-crash-analysis/index.html">
<meta property="og:site_name" content="5ec1cff&#39;s blog">
<meta property="og:description" content="记 LSPosed 的一个随机崩溃的调查过程LSPosed 已经停更数个月，由于缺少维护，问题不断显现。从上个月开始，就看到有不少用户汇报 LSPosed 存在导致系统概率性 crash 或 bootloop 的问题，然而原因却让人摸不着头脑。在最近，经过几天的与问题用户的跟踪调查，总算有了眉目。 初见收到的 crash dump 往往具有下面的特征： 1234567891011121314151">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-06-27T09:04:58.000Z">
<meta property="article:modified_time" content="2024-06-28T07:18:03.742Z">
<meta property="article:author" content="5ec1cff">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/my-blog/img/favicon.png"><link rel="canonical" href="https://5ec1cff.github.io/my-blog/2024/06/27/lsp-crash-analysis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/my-blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/my-blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '记 LSPosed 的一个随机崩溃的调查过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-28 15:18:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style> .avatar-img { display: none; } #pagination.pagination-post { background: #fff; } #pagination.pagination-post .cover { opacity: 1; } :root { --hl-bg: #fff0f4; --hltools-bg: #ffe1e9; --hlscrollbar-bg: #ebaecd; --hlnumber-bg: #fff0f4; --hlnumber-color: #ff2291; --hltools-color: #ff2291; } [data-theme='dark'] { --hl-bg: #191113; --hltools-bg: #4c343a; --hlscrollbar-bg: #ebaecd; --hlnumber-bg: #191113; --hlnumber-color: #ff2291; --hltools-color: #ff2291; --hl-color: #90a4ae; --default-bg-color: #4c343a; }[data-theme='dark'] #footer { background: #4c343a; } </style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAAAMSURBVAiZY/j//z8ABf4C/ljyaw4AAAAASUVORK5CYII=" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/my-blog/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/my-blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/my-blog/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/my-blog/" title="5ec1cff's blog"><span class="site-name">5ec1cff's blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">记 LSPosed 的一个随机崩溃的调查过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-27T09:04:58.000Z" title="发表于 2024-06-27 17:04:58">2024-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-28T07:18:03.742Z" title="更新于 2024-06-28 15:18:03">2024-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="记 LSPosed 的一个随机崩溃的调查过程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="记-LSPosed-的一个随机崩溃的调查过程"><a href="#记-LSPosed-的一个随机崩溃的调查过程" class="headerlink" title="记 LSPosed 的一个随机崩溃的调查过程"></a>记 LSPosed 的一个随机崩溃的调查过程</h1><p>LSPosed 已经停更数个月，由于缺少维护，问题不断显现。从上个月开始，就看到有不少用户汇报 LSPosed 存在导致系统概率性 crash 或 bootloop 的问题，然而原因却让人摸不着头脑。在最近，经过几天的与问题用户的跟踪调查，总算有了眉目。</p>
<h2 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h2><p>收到的 crash dump 往往具有下面的特征：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Process uptime: <span class="number">13</span>s</span><br><span class="line">ZygotePid: <span class="number">8731</span></span><br><span class="line">Cmdline: system_server</span><br><span class="line">pid: <span class="number">8968</span>, tid: <span class="number">9054</span>, name: PackageManager  &gt;&gt;&gt; system_server &lt;&lt;&lt;</span><br><span class="line">uid: <span class="number">1000</span></span><br><span class="line">tagged_addr_ctrl: <span class="number">0000000000000001</span> (PR_TAGGED_ADDR_ENABLE)</span><br><span class="line">signal <span class="number">11</span> (SIGSEGV), code <span class="number">1</span> (SEGV_MAPERR), fault addr <span class="number">0x000000000001001f</span></span><br><span class="line">    x0  b400007291770600  x1  <span class="number">00000071</span>c94177c8  x2  <span class="number">0000000000000000</span>  x3  <span class="number">0000000000000000</span></span><br><span class="line">    x4  <span class="number">0000000000000000</span>  x5  <span class="number">0000000000000000</span>  x6  <span class="number">0000000000000000</span>  x7  <span class="number">00000071156e6000</span></span><br><span class="line">    x8  <span class="number">000000000000f</span>fff  x9  <span class="number">42348</span>aa598a9b938  x10 <span class="number">0000000000000001</span>  x11 <span class="number">0000000002000000</span></span><br><span class="line">    x12 <span class="number">000000000000000</span>c  x13 <span class="number">000000000000000</span>c  x14 <span class="number">0000000000000003</span>  x15 <span class="number">00000000</span>ebad6a89</span><br><span class="line">    x16 <span class="number">00000071156e4</span>be0  x17 <span class="number">0000000000000031</span>  x18 <span class="number">0000007115124000</span>  x19 <span class="number">00000071156e4</span>b20</span><br><span class="line">    x20 b400007146c64400  x21 b400007291811510  x22 <span class="number">00000071e369</span>d000  x23 b40000729176bc80</span><br><span class="line">    x24 <span class="number">00000071156e6000</span>  x25 <span class="number">0000000000000008</span>  x26 <span class="number">0000007126890898</span>  x27 <span class="number">000000000000100</span>a</span><br><span class="line">    x28 <span class="number">00000071156e4</span>d30  x29 <span class="number">00000071156e4</span>af0</span><br><span class="line">    lr  <span class="number">00000071e30</span>a85e8  sp  <span class="number">00000071156e4</span>af0  pc  <span class="number">00000071e30</span>b5448  pst <span class="number">0000000080001000</span></span><br><span class="line"></span><br><span class="line"><span class="number">36</span> total frames</span><br><span class="line">backtrace:</span><br><span class="line">      #<span class="number">00</span> pc <span class="number">000000000042e448</span>  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::JitCodeCache::<span class="built_in">IsMethodBeingCompiled</span>(art::ArtMethod*, art::CompilationKind)+<span class="number">136</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">      #<span class="number">01</span> pc <span class="number">00000000004215e4</span>  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::ScopedCompilation::<span class="built_in">ScopedCompilation</span>(art::jit::Jit*, art::ArtMethod*, art::CompilationKind)+<span class="number">148</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">      #<span class="number">02</span> pc <span class="number">000000000042149</span>c  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::Jit::<span class="built_in">AddCompileTask</span>(art::Thread*, art::ArtMethod*, art::CompilationKind, <span class="type">bool</span>)+<span class="number">76</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">      #<span class="number">03</span> pc <span class="number">00000000007773</span>d8  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (NterpHotMethod+<span class="number">424</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br></pre></td></tr></table></figure>

<p>crash 发生在系统服务，进而导致 zygote 重启。根据收集的多名用户的汇报，导致 crash 的原因无一例外，是在执行 jit 编译的时候，调用的 <code>IsMethodBeingCompiled</code> 函数中发生了错误的解引用，fault addr 均为 <code>0x1001f</code> 。</p>
<p>问题多发生在小米的五月补丁之后的系统上，也有一例 vivo 系统的汇报。</p>
<p>由于 crash 的发生具有随机性，且似乎只出现在特定系统，缺少可稳定复现的方法，导致开发者起初认为是厂商修改的问题。</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>我们借助源码与反汇编进行分析。</p>
<p><strong>反汇编及反编译</strong></p>
<p><img src="/my-blog/images/20240627_01.png"></p>
<p><img src="/my-blog/images/20240627_02.png"></p>
<p>crash 点位于绿色线部分，在解引用 <code>x8+0x20</code> 时候发生了错误。注意到 crashdump 中 <code>x8 = 0xffff</code> 。</p>
<p>为了进一步理解反编译，我们看一看源码：</p>
<p><strong>源码</strong> </p>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/jit/jit_code_cache.cc;l=1287;drc=33d57ac6d1be2127bc31fb55a5054ac84bb7d78d">https://cs.android.com/android/platform/superproject/+/master:art/runtime/jit/jit_code_cache.cc;l=1287;drc=33d57ac6d1be2127bc31fb55a5054ac84bb7d78d</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JitCodeCache::IsMethodBeingCompiled</span><span class="params">(ArtMethod* method, CompilationKind kind)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedDebugDisallowReadBarriers <span class="title">sddrb</span><span class="params">(Thread::Current())</span></span>;</span><br><span class="line">  <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> CompilationKind::kOsr:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ContainsElement</span>(current_osr_compilations_, method);</span><br><span class="line">    <span class="keyword">case</span> CompilationKind::kBaseline:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ContainsElement</span>(current_baseline_compilations_, method);</span><br><span class="line">    <span class="keyword">case</span> CompilationKind::kOptimized:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ContainsElement</span>(current_optimized_compilations_, method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>current_xxx_compilations_ 是一些 std::set ，在 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/jit/jit_code_cache.h;drc=33d57ac6d1be2127bc31fb55a5054ac84bb7d78d">JitCodeCache 结构体</a>中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProfilingInfo objects we have allocated.</span></span><br><span class="line"><span class="function">SafeMap&lt;ArtMethod*, ProfilingInfo*&gt; profiling_infos_ <span class="title">GUARDED_BY</span><span class="params">(Locks::jit_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods we are currently compiling, one set for each kind of compilation.</span></span><br><span class="line"><span class="function">std::set&lt;ArtMethod*&gt; current_optimized_compilations_ <span class="title">GUARDED_BY</span><span class="params">(Locks::jit_lock_)</span></span>;</span><br><span class="line"><span class="function">std::set&lt;ArtMethod*&gt; current_osr_compilations_ <span class="title">GUARDED_BY</span><span class="params">(Locks::jit_lock_)</span></span>;</span><br><span class="line"><span class="function">std::set&lt;ArtMethod*&gt; current_baseline_compilations_ <span class="title">GUARDED_BY</span><span class="params">(Locks::jit_lock_)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/compilation_kind.h;l=25;drc=0d60a2b1eaa2cd2ec3481e49578b77405353efa1">kOsr 枚举值为 0</a> ，因此反编译的条件分支是正确的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">CompilationKind</span> &#123;</span><br><span class="line">  kOsr, <span class="comment">// == 0</span></span><br><span class="line">  kBaseline,</span><br><span class="line">  kOptimized,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/libartbase/base/stl_util.h;l=120;drc=743ce223c81f33f2955c64f39f85ca6c64099cb7">ContainsElement</a> 的实现也很简单，使用 <code>std::find</code> 来查找某个元素是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search for an element with the specified value and return true if it was found, false otherwise.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContainsElement</span><span class="params">(<span class="type">const</span> Container&amp; container, <span class="type">const</span> T&amp; value, <span class="type">size_t</span> start_pos = <span class="number">0u</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_LE</span>(start_pos, container.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">auto</span> start = container.<span class="built_in">begin</span>();</span><br><span class="line">  std::<span class="built_in">advance</span>(start, start_pos);</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(start, container.<span class="built_in">end</span>(), value);</span><br><span class="line">  <span class="keyword">return</span> it != container.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this+0x388</code> 应该指向 std::set 的某个成员。为了分析 stl set 的内存布局，我们可以用 clang dump 出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aarch64-linux-android26-clang++ -Xclang -fdump-record-layouts -c set.cpp&gt;set.txt</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">long</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> it != s.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set 的内存布局如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         <span class="number">0</span> | <span class="keyword">class</span> <span class="title class_">std</span>::set&lt;<span class="type">long</span>&gt;</span><br><span class="line">         <span class="number">0</span> |   <span class="keyword">class</span> <span class="title class_">std</span>::__tree&lt;<span class="type">long</span>, <span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;<span class="type">long</span>&gt;, <span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="type">long</span>&gt; &gt; __tree_</span><br><span class="line">         <span class="number">0</span> |     __iter_pointer __begin_node_</span><br><span class="line">         <span class="number">8</span> |     <span class="keyword">class</span> <span class="title class_">std</span>::__compressed_pair&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_end_node&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node_base&lt;<span class="type">void</span> *&gt; *&gt;, <span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node&lt;<span class="type">long</span>, <span class="type">void</span> *&gt; &gt; &gt; __pair1_</span><br><span class="line">         <span class="number">8</span> |       <span class="keyword">struct</span> <span class="title class_">std</span>::__compressed_pair_elem&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_end_node&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node_base&lt;<span class="type">void</span> *&gt; *&gt;, <span class="number">0</span>&gt; (base)</span><br><span class="line">         <span class="number">8</span> |         <span class="keyword">class</span> <span class="title class_">std</span>::__tree_end_node&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node_base&lt;<span class="type">void</span> *&gt; *&gt; __value_</span><br><span class="line">         <span class="number">8</span> |           pointer __left_</span><br><span class="line">         <span class="number">8</span> |       <span class="keyword">struct</span> <span class="title class_">std</span>::__compressed_pair_elem&lt;<span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node&lt;<span class="type">long</span>, <span class="type">void</span> *&gt; &gt;, <span class="number">1</span>&gt; (base) (empty)</span><br><span class="line">         <span class="number">8</span> |         <span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node&lt;<span class="type">long</span>, <span class="type">void</span> *&gt; &gt; (base) (empty)</span><br><span class="line">         <span class="number">8</span> |           <span class="keyword">struct</span> <span class="title class_">std</span>::__non_trivial_if&lt;<span class="literal">true</span>, <span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node&lt;<span class="type">long</span>, <span class="type">void</span> *&gt; &gt; &gt; (base) (empty)</span><br><span class="line">        <span class="number">16</span> |     <span class="keyword">class</span> <span class="title class_">std</span>::__compressed_pair&lt;<span class="type">unsigned</span> <span class="type">long</span>, <span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;<span class="type">long</span>&gt; &gt; __pair3_</span><br><span class="line">        <span class="number">16</span> |       <span class="keyword">struct</span> <span class="title class_">std</span>::__compressed_pair_elem&lt;<span class="type">unsigned</span> <span class="type">long</span>, <span class="number">0</span>&gt; (base)</span><br><span class="line">        <span class="number">16</span> |         <span class="type">unsigned</span> <span class="type">long</span> __value_</span><br><span class="line">        <span class="number">16</span> |       <span class="keyword">struct</span> <span class="title class_">std</span>::__compressed_pair_elem&lt;<span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;<span class="type">long</span>&gt;, <span class="number">1</span>&gt; (base) (empty)</span><br><span class="line">        <span class="number">16</span> |         <span class="keyword">struct</span> <span class="title class_">std</span>::<span class="built_in">less</span>&lt;<span class="type">long</span>&gt; (base) (empty)</span><br><span class="line">        <span class="number">16</span> |           <span class="keyword">struct</span> <span class="title class_">std</span>::__binary_function_keep_layout_base&lt;<span class="type">long</span>, <span class="type">long</span>, _Bool&gt; (base) (empty)</span><br><span class="line">           | [<span class="keyword">sizeof</span>=<span class="number">24</span>, dsize=<span class="number">24</span>, align=<span class="number">8</span>,</span><br><span class="line">           |  nvsize=<span class="number">24</span>, nvalign=<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p>长度为 24 ，恰好与代码中三个偏移 0x370, 0x388, 0x3a0 的间隔一致，且 param_3 (CompilationKind) 与三个 set 在 JitCodeCache 中的对应顺序也一致。</p>
<p><code>p1Var[4]</code> 也就是 <code>*(p1Var + 32)</code> ，应该对应于 stl set 的红黑树结点的 value 。内存布局印证了这一猜想。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         <span class="number">0</span> | <span class="keyword">class</span> <span class="title class_">std</span>::__tree_node&lt;<span class="type">long</span>, <span class="type">void</span> *&gt;</span><br><span class="line">         <span class="number">0</span> |   <span class="keyword">class</span> <span class="title class_">std</span>::__tree_node_base&lt;<span class="type">void</span> *&gt; (base)</span><br><span class="line">         <span class="number">0</span> |     <span class="keyword">class</span> <span class="title class_">std</span>::__tree_end_node&lt;<span class="keyword">class</span> <span class="title class_">std</span>::__tree_node_base&lt;<span class="type">void</span> *&gt; *&gt; (base)</span><br><span class="line">         <span class="number">0</span> |       pointer __left_</span><br><span class="line">         <span class="number">8</span> |     pointer __right_</span><br><span class="line">        <span class="number">16</span> |     __parent_pointer __parent_</span><br><span class="line">        <span class="number">24</span> |     _Bool __is_black_</span><br><span class="line">        <span class="number">32</span> |   __node_value_type __value_</span><br><span class="line">           | [<span class="keyword">sizeof</span>=<span class="number">40</span>, dsize=<span class="number">40</span>, align=<span class="number">8</span>,</span><br><span class="line">           |  nvsize=<span class="number">40</span>, nvalign=<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p>p1Var 可以看作遍历红黑树结点的指针值。目前我们尚不知道哪一个值传入会导致 crash ，也不知道是在循环的哪一层读取到了错误的地址。</p>
<p>不过回到 crashdump 中，我们注意到了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory near x0 = b400007291770600 ([anon:libc_malloc]):</span><br><span class="line">    <span class="number">00000072917705e0</span> <span class="number">0000000000040007</span> <span class="number">0000006575727408</span>  .........<span class="literal">true</span>...</span><br><span class="line">    <span class="number">00000072917705f</span>0 <span class="number">0000000000000000</span> <span class="number">0000000000000000</span>  ................</span><br><span class="line">    <span class="number">0000007291770600</span> <span class="number">6f</span>632f7865706101 <span class="number">00000071e2</span>d49e09  .apex/co....q...</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0000007291770980</span> b400007291770988 <span class="number">000000000000f</span>fff  ..w.r...........</span><br></pre></td></tr></table></figure>

<p>恰好 <code>*(this + 0x388)</code> 的值就是 0xffff ！这说明可能存在某些代码错误地将这里的值改成了 0xffff 。</p>
<h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>因此我们修改代码， hook IsMethodBeingCompiled 打印出 this 的值，并且判断 <code>*(this+0x388)==0xffff</code> （即问题是否发生），给用户测试。我们观察到这个 0xffff 并非一开始就存在，且 IsMethodBeingCompiled 的调用频率也并不低。</p>
<p>为了调查是谁污染了这个地址，我们使用 stackplz 的硬件断点功能，让用户在设备上运行 stackplz 捕获堆栈。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># thiz 地址由日志取得，似乎一个进程只有一个 JitCodeCache 对象</span></span><br><span class="line">./stackplz --pid `pidof system_server` --brk $((thiz+<span class="number">0</span>x388)):w --stack </span><br></pre></td></tr></table></figure>

<p>经过一天的等待，我们得到了 crash 前的堆栈，我们发现对这个地址的写入大部分情况下来自这个调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2045</span>|<span class="number">4248</span>] event_addr:<span class="number">0x7b3df41388</span> hit_count:<span class="number">12272</span>, Stackinfo:</span><br><span class="line">  #<span class="number">00</span> pc <span class="number">000000000042e638</span>  /apex/com.android.art/lib64/libart.so (art::jit::JitCodeCache::ResetHotnessCounter(art::ArtMethod*, art::Thread*)+<span class="number">136</span>)</span><br><span class="line">  #<span class="number">01</span> pc <span class="number">0000000000422f</span>e0  /apex/com.android.art/lib64/libart.so (art::jit::Jit::EnqueueOptimizedCompilation(art::ArtMethod*, art::Thread*)+<span class="number">48</span>)</span><br><span class="line">  #<span class="number">02</span> pc <span class="number">0000000000229</span>d40  /apex/com.android.art/lib64/libart.so (art_quick_compile_optimized+<span class="number">160</span>)</span><br><span class="line">  #<span class="number">03</span> pc <span class="number">00000000021682</span>c8  /memfd:jit-cache (deleted) (offset <span class="number">0x2000000</span>)</span><br></pre></td></tr></table></figure>

<p>由于上面的 stackplz 没有打印出 +0x388 处的具体值或按照它过滤，因此暂时无法确认就是这个函数的问题。</p>
<h2 id="深入-ResetHotnessCounter"><a href="#深入-ResetHotnessCounter" class="headerlink" title="深入 ResetHotnessCounter"></a>深入 ResetHotnessCounter</h2><p>然而在分析了一下源码之后，发现这个函数来头不小，直指矛盾的中心。直接上图：</p>
<p><img src="/my-blog/images/20240627_03.png"></p>
<p>观察可知，这个函数试图往一个 map profiling_infos_ 的迭代器返回的地址写入值，而写入的值恰好是 0xffff 。</p>
<p>在内存布局上，这个 profiling_info_ 恰好又在那几个 set 上方，因此如果传入的 method 无法在这个 map 中被找到，那么返回了 iterator end ，就有可能发生意外的越界写，从反汇编来看确实如此。</p>
<p>看上去似乎是这部分代码的逻辑存在问题。然而代码对于 find 得到 end 的情形仅有 DCHECK ，即 debug 期的检查，说明这里设计上是总可以被找到的，应该是 LSPosed 的修改导致了问题。</p>
<h2 id="初步结论：被-jit-后的方法被-hook"><a href="#初步结论：被-jit-后的方法被-hook" class="headerlink" title="初步结论：被 jit 后的方法被 hook"></a>初步结论：被 jit 后的方法被 hook</h2><p>因此，我们又给用户编译了一个版本，用于跟踪是哪一个 artMethod 在 profiling_infos_ 找不到。</p>
<p>我们 hook 了 AddProfilingInfoInternal 和 ResetHotnessCounter 函数，发现是一个被 hook 的方法的 backup 被传入了 ResetHotnessCounter 而不存在于 profiling_infos_ ，更进一步地，我们发现这个方法在被 hook 前就已经被 jit 优化。</p>
<p>按照事件发生的顺序的日志如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shouldFilterApplication 的原方法首先被加入到 profiling_infos_</span></span><br><span class="line">AddProfilingInfoInternal: adding <span class="number">0x7541b282c0</span></span><br><span class="line">AddProfilingInfoInternal: adding <span class="number">0x7541b282c0</span> result <span class="number">0x759f628820</span></span><br><span class="line"><span class="comment">// 此时该方法被 hook</span></span><br><span class="line">Done hook: <span class="built_in">target</span>(<span class="number">0x7541b282c0</span>:<span class="number">0x1a200001</span>) -&gt; <span class="number">0x764749a0c0</span>; <span class="built_in">backup</span>(<span class="number">0x74dc522020</span>:<span class="number">0x1a200002</span>) -&gt; <span class="number">0x9c0c2580</span>; <span class="built_in">hook</span>(<span class="number">0x74dc522040</span>:<span class="number">0x12280009</span>) -&gt; <span class="number">0x75c05ef260</span></span><br><span class="line"><span class="comment">// 此时因为被 hook 方法被调用而导致调用 ResetHotnessCounter 被传入了 backup 的 ArtMethod</span></span><br><span class="line"><span class="comment">// 然而实际在 profiling_infos_ 的是原 ArtMethod</span></span><br><span class="line">ResetHotnessCounter: no profilingInfo found <span class="keyword">for</span> <span class="number">0x74dc522020</span> (count <span class="number">1</span>) !!!</span><br><span class="line">ResetHotnessCounter: method <span class="number">0x74dc522020</span> boolean com.android.server.pm.AppsFilterBase.<span class="built_in">shouldFilterApplication</span>(com.android.server.pm.snapshot.PackageDataSnapshot, <span class="type">int</span>, java.lang.Object, com.android.server.pm.pkg.PackageStateInternal, <span class="type">int</span>) </span><br><span class="line">flags=<span class="number">0x1a200002</span> entry=<span class="number">0x9c0c2580</span> info <span class="number">0x0</span> lastNotFound <span class="number">0x0</span></span><br><span class="line"><span class="comment">// 因此导致 find 返回 end ，从而发生错误写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原方法入口点处于 jit 中</span></span><br><span class="line"><span class="number">0000000&#x27;9</span>c051000<span class="number">-00000000&#x27;9e050</span>fff r-x   <span class="number">2000000</span>   <span class="number">2000000</span>  /memfd:jit-<span class="built_in">cache</span> (deleted)</span><br></pre></td></tr></table></figure>

<p>我们还跟踪了 AddProfilingInfoInternal 和 ResetHotnessCounter 的调用堆栈（后者是导致 find artMethod &#x3D;&#x3D; end 的时候）</p>
<blockquote>
<p>借助 bionic 的信号处理机制，通过 <code>raise(35)</code> 可以使用系统 crash dumper 打印当前堆栈</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddProfilingInfoInternal</span></span><br><span class="line">#<span class="number">00</span> pc <span class="number">00000000000</span>ec788  /apex/com.android.runtime/lib64/bionic/libc.<span class="built_in">so</span> (tgkill+<span class="number">8</span>) (BuildId: <span class="number">84</span>a42637b3a421b801818f5793418fca)</span><br><span class="line">#<span class="number">01</span> pc <span class="number">000000000003445</span>c  /memfd:jit-<span class="built_in">cache</span> (deleted)</span><br><span class="line">#<span class="number">02</span> pc <span class="number">000000000042</span>ebc4  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::JitCodeCache::<span class="built_in">AddProfilingInfo</span>(art::Thread*, art::ArtMethod*, std::__1::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>, std::__1::allocator&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &gt; <span class="type">const</span>&amp;)+<span class="number">68</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">03</span> pc <span class="number">0000000000435030</span>  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::ProfilingInfo::<span class="built_in">Create</span>(art::Thread*, art::ArtMethod*)+<span class="number">528</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">04</span> pc <span class="number">0000000000430254</span>  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::JitCodeCache::<span class="built_in">NotifyCompilationOf</span>(art::ArtMethod*, art::Thread*, art::CompilationKind, <span class="type">bool</span>)+<span class="number">756</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">05</span> pc <span class="number">000000000041b</span>508  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::Jit::<span class="built_in">CompileMethodInternal</span>(art::ArtMethod*, art::Thread*, art::CompilationKind, <span class="type">bool</span>)+<span class="number">872</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">06</span> pc <span class="number">00000000004266</span>ec  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::JitCompileTask::<span class="built_in">Run</span>(art::Thread*)+<span class="number">684</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">07</span> pc <span class="number">00000000006</span>cb810  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::ThreadPoolWorker::<span class="built_in">Run</span>()+<span class="number">112</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">08</span> pc <span class="number">00000000006</span>cb2c0  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::ThreadPoolWorker::<span class="built_in">Callback</span>(<span class="type">void</span>*)+<span class="number">176</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">09</span> pc <span class="number">0000000000101</span>d5c  /apex/com.android.runtime/lib64/bionic/libc.<span class="built_in">so</span> (__pthread_start(<span class="type">void</span>*)+<span class="number">204</span>) (BuildId: <span class="number">84</span>a42637b3a421b801818f5793418fca)</span><br><span class="line">#<span class="number">10</span> pc <span class="number">0000000000095b</span>c0  /apex/com.android.runtime/lib64/bionic/libc.<span class="built_in">so</span> (__start_thread+<span class="number">64</span>) (BuildId: <span class="number">84</span>a42637b3a421b801818f5793418fca)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResetHotnessCounter</span></span><br><span class="line"><span class="comment">// 可以发现确实是被 hook 方法被调用的时候出现</span></span><br><span class="line">#<span class="number">00</span> pc <span class="number">00000000000</span>ec788  /apex/com.android.runtime/lib64/bionic/libc.<span class="built_in">so</span> (tgkill+<span class="number">8</span>) (BuildId: <span class="number">84</span>a42637b3a421b801818f5793418fca)</span><br><span class="line">#<span class="number">01</span> pc <span class="number">0000000000034188</span>  /memfd:jit-<span class="built_in">cache</span> (deleted) (lsposed)</span><br><span class="line">#<span class="number">02</span> pc <span class="number">0000000000422f</span>e0  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::jit::Jit::<span class="built_in">EnqueueOptimizedCompilation</span>(art::ArtMethod*, art::Thread*)+<span class="number">48</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">03</span> pc <span class="number">0000000000229</span>d40  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art_quick_compile_optimized+<span class="number">160</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">04</span> pc <span class="number">0000000002062</span>df0  /memfd:jit-<span class="built_in">cache</span> (deleted) (offset <span class="number">0x2000000</span>) (com.android.server.pm.AppsFilterBase.shouldFilterApplication+<span class="number">1568</span>) (jit cache)</span><br><span class="line">#<span class="number">05</span> pc <span class="number">00000000002109</span>a4  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art_quick_invoke_stub+<span class="number">612</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">06</span> pc <span class="number">0000000000253b</span>0c  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::ArtMethod::<span class="built_in">Invoke</span>(art::Thread*, <span class="type">unsigned</span> <span class="type">int</span>*, <span class="type">unsigned</span> <span class="type">int</span>, art::JValue*, <span class="type">char</span> <span class="type">const</span>*)+<span class="number">172</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">07</span> pc <span class="number">000000000064b</span>734  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (_jobject* art::<span class="built_in">InvokeMethod</span>&lt;(art::PointerSize)<span class="number">8</span>&gt;(art::ScopedObjectAccessAlreadyRunnable <span class="type">const</span>&amp;, _jobject*, _jobject*, _jobject*, <span class="type">unsigned</span> <span class="type">long</span>)+<span class="number">1588</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">08</span> pc <span class="number">00000000005</span>c3800  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::<span class="built_in">Method_invoke</span>(_JNIEnv*, _jobject*, _jobject*, _jobjectArray*) (.__uniq<span class="number">.165753521025965369065708152063621506277</span>)+<span class="number">32</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">09</span> pc <span class="number">00000000000</span>a2578  /system/framework/arm64/boot.<span class="built_in">oat</span> (art_jni_trampoline+<span class="number">120</span>) (BuildId: ef0baacfbe47e6c11614583471d5d5b98b1584c5)</span><br><span class="line">#<span class="number">10</span> pc <span class="number">00000000002109</span>a4  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art_quick_invoke_stub+<span class="number">612</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">11</span> pc <span class="number">0000000000253b</span>0c  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::ArtMethod::<span class="built_in">Invoke</span>(art::Thread*, <span class="type">unsigned</span> <span class="type">int</span>*, <span class="type">unsigned</span> <span class="type">int</span>, art::JValue*, <span class="type">char</span> <span class="type">const</span>*)+<span class="number">172</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">12</span> pc <span class="number">000000000064</span>d14c  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::JValue art::<span class="built_in">InvokeVirtualOrInterfaceWithVarArgs</span>&lt;art::ArtMethod*&gt;(art::ScopedObjectAccessAlreadyRunnable <span class="type">const</span>&amp;, _jobject*, art::ArtMethod*, std::__va_list)+<span class="number">460</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">13</span> pc <span class="number">000000000064</span>d3dc  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::JValue art::<span class="built_in">InvokeVirtualOrInterfaceWithVarArgs</span>&lt;_jmethodID*&gt;(art::ScopedObjectAccessAlreadyRunnable <span class="type">const</span>&amp;, _jobject*, _jmethodID*, std::__va_list)+<span class="number">92</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">14</span> pc <span class="number">0000000000480984</span>  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (art::JNI&lt;<span class="literal">false</span>&gt;::<span class="built_in">CallObjectMethodV</span>(_JNIEnv*, _jobject*, _jmethodID*, std::__va_list)+<span class="number">660</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">15</span> pc <span class="number">0000000000044e78</span>  /memfd:jit-<span class="built_in">cache</span> (deleted) (lsposed)</span><br><span class="line">#<span class="number">16</span> pc <span class="number">00000000000518</span>d8  /memfd:jit-<span class="built_in">cache</span> (deleted) (lsposed)</span><br><span class="line">#<span class="number">17</span> pc <span class="number">00000000020b</span>19cc  /memfd:jit-<span class="built_in">cache</span> (deleted) (offset <span class="number">0x2000000</span>) (art_jni_trampoline+<span class="number">156</span>) (jit cache)</span><br><span class="line">#<span class="number">18</span> pc <span class="number">000000000207</span>c10c  /memfd:jit-<span class="built_in">cache</span> (deleted) (offset <span class="number">0x2000000</span>) (org.lsposed.lspd.impl.LSPosedBridge$NativeHooker.callback+<span class="number">1756</span>) (jit cache)</span><br><span class="line">#<span class="number">19</span> pc <span class="number">000000000020</span>a330  /apex/com.android.art/lib64/libart.<span class="built_in">so</span> (nterp_helper+<span class="number">4016</span>) (BuildId: bfccbd9698a0ee7ef72cfa3ee7389215)</span><br><span class="line">#<span class="number">20</span> pc <span class="number">00000000000002</span>ce  [anon:dalvik-DEX data] (LSPHooker_.shouldFilterApplication+<span class="number">62</span>)</span><br><span class="line">#<span class="number">21</span> pc <span class="number">00000000020b</span>e8f0  /memfd:jit-<span class="built_in">cache</span> (deleted) (offset <span class="number">0x2000000</span>) (com.android.server.pm.ComputerEngine.shouldFilterApplication+<span class="number">1696</span>)</span><br></pre></td></tr></table></figure>

<p>因此，结论上来看，是 lsplant 对已经 jit 的 ArtMethod （且被加入到 profiling_infos_ ）进行了 hook 后，调用被 hook 方法导致调用 ResetHotnessCounter ，并传入了错误的 ArtMethod 地址导致错误写入，从而在其他 jit 编译发生的时候调用 IsMethodBeingCompiled 时访问错误的地址。</p>
<p>此时我们发现一个现象：如果第一次正常启动，则手动触发软重启（即杀掉 zygote）可以大概率复现 bug ，因为下一次 zygote 启动后会立即触发这个 bug ，这大大地加快了调试的进程。考虑到触发的方法是 HMA hook 的 shouldFilterApplication ，而这个方法在开机的时候会因为计算缓存被频繁调用，因此存在 HMA 的情况下就有很大的概率触发。但是仍然没法解释为什么第一次启动大概率不会出现问题，而是要等系统运行很久才发生问题。</p>
<p>此外，系统的 services.jar 一般都应该是被优化编译的，且 oat 保存在系统镜像中。但是为什么这里 hook 的方法虽然在 services.jar 中，却需要 jit 编译呢？jit 编译为什么先于 hook 触发呢？这些还需要进一步调查。不过，有人反馈使用了 FrameworkPatchGo 等模块也触发了这个 bug ，显然这种替换 jar 的模块会导致已有的 oat 失效，因此使用 jit 是正常情况。</p>
<h2 id="临时修复"><a href="#临时修复" class="headerlink" title="临时修复"></a>临时修复</h2><p>我给出了一个<a target="_blank" rel="noopener" href="https://github.com/5ec1cff/LSPlant/commit/7a08c38727aa741d4e7581e1156df0ec880642f0">修复</a>，通过 hook ResetHotnessCounter ，检查 ArtMethod 是否在 profiling_infos_ 中，如果不在，则尝试从 hook 记录中查找备份方法的原方法并传入给原函数。</p>
<h2 id="稳定复现"><a href="#稳定复现" class="headerlink" title="稳定复现"></a>稳定复现</h2><p>尽管上文提到在特定系统中手动软重启可以快速复现，但是我们仍然需要一个稳定的触发方法。</p>
<p>TODO</p>
<h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>未完待续</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://5ec1cff.github.io/my-blog">5ec1cff</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://5ec1cff.github.io/my-blog/2024/06/27/lsp-crash-analysis/">https://5ec1cff.github.io/my-blog/2024/06/27/lsp-crash-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://5ec1cff.github.io/my-blog" target="_blank">5ec1cff's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAAAMSURBVAiZY/j//z8ABf4C/ljyaw4AAAAASUVORK5CYII=" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/my-blog/2024/06/24/android-arm64-hwbkpt/" title="Android arm64 在 ptrace 中使用硬件断点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android arm64 在 ptrace 中使用硬件断点</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAAAMSURBVAiZY/j//z8ABf4C/ljyaw4AAAAASUVORK5CYII=" onerror="this.onerror=null;this.src='/my-blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">5ec1cff</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/my-blog/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/my-blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/my-blog/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/5ec1cff"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/5ec1cff" target="_blank" title="Github"><i class="fab fa-github" style="color: #000000;"></i></a><a class="social-icon" href="https://t.me/real5ec1cff" target="_blank" title="Telegram"><i class="fab fa-telegram" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0-LSPosed-%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%B4%A9%E6%BA%83%E7%9A%84%E8%B0%83%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">记 LSPosed 的一个随机崩溃的调查过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%A7%81"><span class="toc-number">1.1.</span> <span class="toc-text">初见</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">动态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5-ResetHotnessCounter"><span class="toc-number">1.4.</span> <span class="toc-text">深入 ResetHotnessCounter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E7%BB%93%E8%AE%BA%EF%BC%9A%E8%A2%AB-jit-%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95%E8%A2%AB-hook"><span class="toc-number">1.5.</span> <span class="toc-text">初步结论：被 jit 后的方法被 hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E4%BF%AE%E5%A4%8D"><span class="toc-number">1.6.</span> <span class="toc-text">临时修复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.7.</span> <span class="toc-text">稳定复现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90"><span class="toc-number">1.8.</span> <span class="toc-text">进一步分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my-blog/2024/06/27/lsp-crash-analysis/" title="记 LSPosed 的一个随机崩溃的调查过程">记 LSPosed 的一个随机崩溃的调查过程</a><time datetime="2024-06-27T09:04:58.000Z" title="发表于 2024-06-27 17:04:58">2024-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my-blog/2024/06/24/android-arm64-hwbkpt/" title="Android arm64 在 ptrace 中使用硬件断点">Android arm64 在 ptrace 中使用硬件断点</a><time datetime="2024-06-24T10:51:39.000Z" title="发表于 2024-06-24 18:51:39">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my-blog/2024/01/31/avd-ksu2/" title="在 AVD 上使用 KernelSU - 第二回 -">在 AVD 上使用 KernelSU - 第二回 -</a><time datetime="2024-01-31T05:58:48.000Z" title="发表于 2024-01-31 13:58:48">2024-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my-blog/2024/01/16/avd-ksu/" title="在 AVD 上使用 KernelSU">在 AVD 上使用 KernelSU</a><time datetime="2024-01-16T15:17:20.000Z" title="发表于 2024-01-16 23:17:20">2024-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my-blog/2023/12/06/lsp-native-hook-crash/" title="记一次 LSPosed Native Hook 偶现崩溃">记一次 LSPosed Native Hook 偶现崩溃</a><time datetime="2023-12-06T11:40:56.000Z" title="发表于 2023-12-06 19:40:56">2023-12-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 5ec1cff</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/my-blog/js/utils.js"></script><script src="/my-blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>